## **equals 재정의 시 hashCode도 재정의하기**

**1. hashCode 재정의**
- equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 함
- Object 명세
> - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.
    단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
> - equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
> - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

- hashCode 재정의를 잘못했을 경우 **두 번째 조항**에서 문제가 됨\
==> 논리적으로 같은 객체는 `같은 해시코드`를 반환
---
**2. hashCode 구현**
```java
@Override
public int hashCode() {
  return 42;
}
```
- 동치인 모든 객체에서 똑같은 해시코드를 반환한다는 점에서 적법
- 모든 객체에게 똑같은 값만 내어주므로 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 연결 리스트(linked list)처럼 동작\
==> 평균 수행 시간이 O(1)인 해시테이블이 O(n)으로 느려짐

**`좋은 hashCode를 작성하는 요령`**
> 1. int 변수 result를 선언한 후 값 c로 초기화한다. 이때 c는 해당 객체의 첫 번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드\
     (여기서 핵심 팰드란 equals 비교에 사용되는 필드)
> 2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행
> > a. 해당 필드의 해시코드 c를 계산\
> > > 1. 기본 타입 필드라면, Type.hashCode(f)를 수행 (여기서 Type은 해당 기본 타입의 박싱 클래스)\
> > > 2. 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 hashCode를 재귀적으로 호출\
         계산이 더 복잡해질 것 같으면, 이 필드의 표준형(canonical representation)을 만들어 그 표준형의 hashCode를 호출\
         필드의 값이 null이면 0을 사용(다른 상수도 괜찮지만 전통적으로 0을 사용)
> > > 3. 필드가 배열이라면, 핵심 원소 각각을 펼도 필드처럼 다룸\
         이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 2.b 방식으로 갱신\
         배열에 핵심원소가 하나도 없다면 단순히 상수(0 추천)를 사용\
         모든 원소가 핵심 원소라면 Arrays.hashCode 사용

> > b. 단계 2.a에서 계산한 해시코드 c로 result를 갱신
> > ```java
> > result = 31 * result _ c;
> > ```
> 3. result를 반환

- 단계 2.b의 곱셈 : 필드를 곱하는 순서에 따라 result 값이 달라지게 함
---
**3. 양질의 equals 메서드 구현 방법**
1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인
2. instanceof 연산자로 입력이 올바른 타입인지 확인
3. 입력을 올바른 타입으로 형변환
4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사
---
**4. 주의사항**
1. equals를 재정의할 땐 hashCode도 반드시 재정의
2. 너무 복잡하게 해결하려 들지 않기
`ex) File 클래스라면, 심볼릭 링크를 비교해 같은 파일을 가리키는지를 확인하려 하면 안 됨`
3. Object 오의 타입을 매개변수로 받는 equals 메서드는 선언하지 않기
---
**5. 오픈소스**
- 구글 AutoValue

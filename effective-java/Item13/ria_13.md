### clone 재정의는 주의해서 진행하라

#### clone 규약

- x.clone() != x 반드시 true
  - 복사본은 원본과 서로 다른 인스턴스를 참조해야 한다.
  - clone() 메서드 호출 시 새로운 인스턴스가 생성되는데, 이 때 생성자를 이용하지 않음!
- x.clone().getClass() == x.getClass() 반드시 true
  - 복사본과 원본은 동일한 클래스여야 한다.
- x.clone().equals() true가 아닐 수도 있다.
  - 달라져야 하는 필드값을 다르게 설정하면 false가 나올 수 있다.
    - ex. 객체를 식별하는 유일한 필드값
- 불변 객체라면 다음으로 충분하다.
  - Cloneable 인터페이스를 구현하고 clone 메서드를 재정의한다. 이 때, super.clone()을 사용해야 한다.
  - Cloneable 인터페이스에는 어떠한 메서드도 정의되어 있지 않지만, Object 클래스의 clone 메서드의 동작 방식을 결정한다.

##### 생성자 호출과 clone 메서드와의 차이점

super.clone()을 어디서 호출했느냐에 따라 타입이 달라진다. 그러나, 생성자 호출을 할 경우 하위 클래스에서 clone()을 호출할 때 상위 클래스 타입의 객체를 반환하기 때문에 두 번째 규약이 깨지게 된다.

#### 가변 객체의 clone 구현하는 방법

- 접근 제한자는 public, 반환 타입은 자신의 클래스로 변경한다.
- super.clone()을 호출한 뒤 필요한 필드를 적절히 수정한다.
  - 배열을 복제할 때는 배열의 clone 메서드를 사용하라.
    - 배열의 clone 메서드는 원본 배열과 똑같은 배열을 반환한다.
  - 경우에 따라 final을 사용할 수 없을지도 모른다.
  - 필요한 경우 deep copy를 해야한다.
  - super.clone으로 객체를 만든 뒤, 고수준 메서드를 호출하는 방법도 있다.
  - 오버라이딩 할 수 있는 메서드는 참조하지 않도록 조심해야 한다.
    - 하위 클래스에서 재정의하는 경우 변경될 수 있기 때문이다.
  - 상속용 클래스는 Cloneable을 구현하지 않는 것이 좋다.
  - Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 동기화를 해야 한다.

#### clone 대신 권장하는 방법

- "복사 생성자" 또는 변환 생성자, "복사 팩터리" 또는 변환 팩터리
- 생성자를 쓰지 않으며, 모호한 규약, 불필요한 검사 예외, final 용법 방해 등에서 벗어날 수 있다.
- 또 다른 큰 장점 중 하나로 인터페이스 타입의 인스턴스를 인수로 받을 수 있다.
  - 클라이언트가 복제본의 타입을 결정할 수 있다.
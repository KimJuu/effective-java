## Item13 

> clone 재정의는 주의해서 진행하라

### clone 규약

- x.clone() != x 반드시 true

    - 원본과 복사본은 서로 다른 인스턴스야 한다.

- x.clone().getCloass() == x.getClass() 반드시 true

- x.clone().equals(x) true가 아닐 수도 있다.

    - 복사하더라도, 식별자가 다를 수 있다.

### 불변 객체 clone 규약

- Cloneable 인터페이스를 구현하고

- clone 메서드를 재정의한다. 이때 super.clone()을 사용해야 한다.

### 가변 객체 clone 규약

- 접근 제한자는 public, 반환 타입은 자신의 클래스로 변경한다.

- super.clone을 호출한 뒤 필요한 필드를 적절히 수정한다.

    - 배열을 복제할 때는 배열의 clone 메서드를 사용하라.

    - 경우에 따라 final을 사용할 수 없을지도 모른다.

    - 필요한 경우 deep copy를 해야 한다.

    - super.clone으로 객체를 만든 뒤, 고수준 메서드를 호출하는 방법도 있다.

    - 오버라이딩 할 수 있는 메서드는 참조하지 않도록 조심해야 한다.

    - 상속용 클래스는 Cloneable을 구현하지 않는 것이 좋다.

    - Cloneable을 구현한 쓰레드 안전 클래스를 작성할 때는 동기화를 해야 한다.

### clone 대신 권장하는 방법

- clone은 사용하기에 복잡하다 -> 생성자를 활용하거나, 팩토리 메서드를 사용하자

- "복사 생성자" 또는 변환 생성자, "복사 팩터리" 또는 변환 팩터리.

- 생성자를 쓰지 않으며, 모호한 규약, 불필요한 검사 예외, final 용법 방해 등에서 벗어날 수 있다.

- 또 다른 큰 장점 중 하나로 인터페이스 타입의 인스턴스를 리턴할 수 있다.

    - 클라이언트가 복제본의 타입을 결정할 수 있다.

 
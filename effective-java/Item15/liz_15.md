잘 설계된 컴포넌트란?  클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐


Controller <——>  Service (인터페이스) <———>  ServiceImpl  


소프트웨어 설계의 근간 ?  정보 은닉


정보 은닉 장점

- 여러 컴포넌트를 병렬로 개발 할 수 있다 -> 시스템 개발 속도를 높인다
- 각 컴포넌트를 빨리 파악하여 디버깅할 수 있어서 관리 비용을 낮춘다
- 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있다
- 개별 컴포넌트 동작을 검증할 수 있어서 큰 시스템을 제작하는 난이도를 낮춰준다

=>  정보 은닉 근간?  각 컴포넌트 별 독립성 


——————————————————————————————————————————————————————


어떻게 하면 정보 은닉을 잘 할 수 있나?

접근 제어 메커니즘 

- 클래스
- 인터페이스
- 멤버의 접근성(접근 허용 범위)


각 요소의 접근성은 그 요소가 선언된 위치, 접근 제한ss자 ( private, protected, public) 으로 정해진다.

이 “접근 제한자”를 제대로 활용하는 것이 정보 은닉의 핵심

——————————————————————————————————————————————————————

접근제한자 종류?

- Private : 멤버를 선언한 톱레벨 클래스에서만 접ss근 가능
- Package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 할 수 있다.
- Protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
- Public : 모든 곳에서 접근할 수 있다.

——————————————————————————————————————————————————————


어떻게 하면 접근 제한자를 제대로 활용할 수 있나?

기본 원칙 :  모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.  ->  각 컴포넌트 별 독립성,  각 컴포넌트를 호출 할 수 있는 제한도 최소화 

——————————————————————————————————————————————————————

어떻게 하면 접근성을 가능한 한 좁힐 수 있나?

1. 패키지 외부에서 쓸 이유가 없다면 package-private으로 선언하자

톱레벨클래스, 인터페이스에 줄 수 있는 접근 제한자 옵션 : Package-private, public 

public으로 선언한 경우 -> 공개 API
Package-private 선언한 경우 -> 해당 패키지 안에서만 이용

 생각해봐야 하는 점?
A. 패키지 외부에서 사용해야하는지
B. 수정, 교체, 제거가 일어났을 때 구현의 편리함
B-1.  만약 public으로 선언한다면 하위 호환을 위해 영원히 관리해줘야함


2. Package-private 으로 사용하는 톱레벨 클래스, 인터페이스에서 private static으로 중첩시켜보자

톱레벨로 두면 같은 패키지의 모든 클래스가 접근 할 수 있지만, private static으로 중첩시키면 바껕 클래스 하나에서만 접근 할 수 있기때문



3. 클래스의 공개 API를 설계 후, 그 이외의 모든 멤버는 private으로 만들고 다른 클래스가 접근해야하는 멤버에 한하여 package-private으로 풀어주자

4. Protected 멤버의 수는 적을 수록 좋다
	package-private -> protected 그 멤버에 접근할 수 있는 대상 범위가 넓어짐. Public 클래스의 protected멤버는 공개 API이므로 영원히 지원해야함

5. Public 큺래스의 인스턴스 필드는 되도록 public이 아니어야한다.
	필드와 관련된 모든것에 불변을 보장하기 힘들어지며, public 가변필드를 갖는 클래스는 일반적으로 스레드 안정하지 않기 때문이다.

 	=> public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라 (ITEM 16)
	
￼
￼

패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.
  
6.상수인 public static final 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.
- 필드와 관련된 모든것에 불변을 보장하기 힘들어지며, public 가변필드를 갖는 클래스는 일반적으로 스레드 안정하지 않기 때문이다.
- 가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다. (참조된 객체가 수정될 수 있기 때문이다.)

7.클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.
* 이런 필드나 접근자를 제공한다면 클라이언트에서 배열 내용을 수정할 수 있게 된다.	
* 길이가 0이 아닌 배열은 모두 변경가능하니 주의해야 한다.

￼

위 코드는 클라이언트에서 배열 내용을 수정이 가능하다. 이런 상황을 방지하기 위한 방법에는 2가지가 있다.
[첫 번째 해결방법: private 배열과 public 불변리스트 추가]

private static final Integer[] VALUES = {5, 3, 2};
public static final List<Integer> VALUES_LIST = Collections.unmodifiableList(Arrays.asList(VALUES));

첫 번째 해결방법은 기존의 public 배열을 private 배열로 만들고 public 불변 리스트를 추가하는 것이다.


[두 번째 해결방법: private 배열과 복사본을 반환하는 public 메서드 추가]

￼
두 번째 해결방법은 기존의 public 배열을 private 배열로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법이다. (방어적 복사)

8. 자바 9에서 추가된 두가지 암묵적 접근 수준
모듈 시스템을 사용해서 외부에서의 접근을 제어할 수 있다.
* 클래스가 패키지의 묶음이듯 모듈은 패키지의 묶음이다. 모듈은 속하는 패키지중 공개할 것들을 선언(module-info.java 파일에)한다.
* protected 혹은 public 멤버라도 해당 피키지를 공개하지 않았다면 모듈 외부에서 접근이 불가능하다. 물론 모듈 안에서 exports로 선언했는지에 영향을 받지 않는다.
* 모듈 시스템을 사용하면 클래스를 외부에 공개하지 않고 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있다.
* 앞서 다룬 4개의 기존 접근수준과 달리 모듈에 적용되는 새로운 두 접근 수준은 상당히 주의해서 사용해야 한다.
* 모듈의 JAR파일을 애플리케이션의 클래스패스(classpath)에 두면 그 모듈안의 모든 패키지는 마치 모듈이 없는 것처럼 행동한다. 즉, 모듈이 공개됐는지 여부와 관계없이 public 클래스가 선언한 모든 public 혹은 protected 멤버를 모듈 밖에서도 접근할 수 있게 된다.


——————————————————————————————————————————————————————

멤버 접근성을 좁히지 못하게 방해하는 제약

상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래서에서보다 좁게 설정할 수 없다는 것 -> 리스코프 치환 원칙을 지키기 위해 필요하다


리스코프 치환 원칙(LSP)?

상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다 -> 특정 메소드가 상위 타입을 인자로 사용한다고 할 때, 그 타입의 하위 타입도 문제 없이 정상적으로 작동을 해야 한다는 것


예시 ) LSP위반 


￼

	
 calculateDiscountAmount() 메소드는 Item 을 받아서 할인 금액을 알려준다.
 
이때 요구사항이 변경되어서 특정 item에는 할인을 적용하지 않는다고 한다. 그래서 Item을 상속받는 SpecialItem 클래스를 구현했다. 그러면 Coupon 클래스는 다음과 같이 바뀔 것이다.



￼



Item의 하위 타입(SpecialItem)을 Coupon에 넘겨주자 원래 있던 기능이 잘 동작하지 못하게 되었고, 이를 해결하기 위해 instanceof로 예외처리를 해준 모습이다.
이는 앞선 예시에서 살펴본 바와 같이 LSP를 위반한 것이며, 이를 잘못된 방식으로 해결한 예이다. 만약 아이템과 관련된 정책이 늘어난다면, Coupon 역시 계속해서 수정해주어야 하며, OCP에도 어긋나게 된다.
 
그렇다면 이를 바로잡으려면 어떻게 해야할까?
Item을 더 정교하게 추상화하면 된다.

￼

할인이 가능한지 여부를 판단하는 기능을 Item에 포함시켰다.
￼
이제 Coupon 클래스에 Item이 오든, SpecialItem이 오든, 그밖에 다른 하위 타입의 클래스가 오든 Coupon 클래스는 수정하지 않아도 된다. 



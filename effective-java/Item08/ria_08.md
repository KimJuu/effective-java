### finalizer와 cleaner 사용을 피하라

자바가 제공하는 두 가지 객체 소멸자인 finalizer와 cleaner의 사용 자제를 크게 6가지 이유로 설명한다.

#### finalize와 cleaner는 즉시 수행된다는 보장이 없다.
finalizer나 cleaner를 얼마나 신속히 수행할지는 전적으로 GC 알고리즘에 달려 있으며, GC마다 다르다.

#### 인스턴스의 자원 회수가 지연될 수 있다.
finalizer 스레드는 다른 애플리케이션의 스레드보다 우선순위가 낮아 finalization queue에 객체가 쌓여 OutOfMemory가 발생할 수 있다.
cleaner는 자신을 수행할 스레드를 제어할 수 있어 조금 낫긴 하지만, 여전히 GC의 통제하에 있으며 즉시 수행된다는 보장이 없다.

#### finalizer나 cleaner의 수행 시점뿐만 아니라 수행 여부조차 보장하지 않는다.
데이터베이스 같은 공유 자원의 영구 락(lock) 해제를 finalizer나 cleaner에 맡겨 놓으면 분산 시스템 전체가 서서히 멈출 것이다.

#### finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.
잡지 못한 예외 때문에 해당 객체는 마무리가 덜 된 상태로 남을 수 있다.
잡지 못한 예외가 발생하더라도 finalizer는 경고조차 출력하지 않는다. cleaner를 사용하는 라이브러리는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하지 않지만 사용하지 않는 것을 권장한다.

#### finalizer와 cleaner는 심각한 성능 문제를 동반한다.
finalizer는 GC의 효율을 떨어뜨리기 때문에 성능 저하를 초래한다.

#### finalizer는 심각한 보안 문제를 일으킬 수 있다.
생성자나 직렬화 과정에서 예외가 발생하면, 생성되다 만 객체에서 악의적인 하위 클래스의 finlizer가 수행될 수 있게 된다. 
따라서, final이 아닌 클래스를 finalizer 공격으로부터 방어하려면 아무 일도 하지 않는 finalize 메서드를 만들고 fianl로 선언해야 한다.

책에서는 finalizer나 cleaner의 사용을 지양하고 있으며, AutoCloseable을 구현하고, 인스턴스를 다 쓰고 나면 close 메서드를 호출하는 방법으로 대안을 제공하고 있다.

그렇다면, 언제 finalizer와 cleaner를 사용하면 좋을까?

#### 안전망 역할
finalizer나 cleaner가 즉시 호출된다는 보장은 없지만, 클라이언트가 하지 않은 자원 회수를 늦게라도 해주는 안전망 역할이다.

#### 네이티브 피어
네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다. 네이티브 피어는 자바 객체가 아니기 때문에 GC는 그 존재를 알지 못하기 때문에 자바 피어를 회수할 때 네이티브 객체까지 회수하지 못한다.
이 때, finalizer나 cleaner를 사용하면 되는데 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 사용하는 것이 좋다.

#### 출처
- 이펙티브 자바
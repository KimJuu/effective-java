### equals 문제를 회피하는 가장 쉬운 방법은?
  아예 재정의하지 않는 것. 
  
  재정의하지 않아도 되는 경우 
  1. 각 인스턴스가 본질적으로 고유하다.
  2. 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
  3. 상위 클래서에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
  4. 클래스가 private 이거나 package-private이고 equals메소드를 호출할 일이 없다.

### 언제 equals를 재정의해야 할까.
  객체 식별성(두 객체의 물리적 일치 여부)이 아닌 논리적 동치성을 확인해야 하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때.
  주로 값 클래스가 이에 해당한다. (Integer나 String처럼 값을 표현하는 클래스)
  
  equals가 논리적 동치성을 확인하도록 재정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대감을 충족함을 물론 Map의 키와 Set의 원소로 사용할 수 있게 된다.
  
  값 클래스라고 해도 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 클래스라면 재정의하지 않아도 된다.
  (Singleton or Enum)
  
### equals 메서드의 규약
  1. 반사성 - null이 아닌 모든 참조값 x에 대해 x.equals(x) 는 true이다.
  2. 대칭성 - null이 아닌 모든 참조값 x,y에 대해 x.equals(y)가 true이면 y.equals(x)도 true이다.
  3. 추이성 - null이 아닌 모든 참조값 x,y,z에 대해 x.equals(y), x.equals(z)가 true이면 y.equals(z)도 true이다.
  4. 일관성 - null이 아닌 모든 참조값 x,y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
  5. null아님 - null이 아닌 모든 참조값 x에 대해 x.equals(null)은 false이다.
  
  수많은 클래스는 객체가 equals 규약을 지킨다고 가정하고 동작한다.

### Object명세에서 말하는 동치관계란?
  집합을 서로 같은 원소들로 이루어진 부분으로 나누는 연산. 이 부분집합을 동치류(동치 클래스)라고 한다.
  
  추이성을 위한반 방식은 무한 재귀에 빠질 위험이 있다.
  구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
  
  구체 클래스를 확장해 새로운 값을 추가하면서, equals 규약을 만족시킬 방법은 없다.
  이럴 때 상속 대신 컴포지션을 사용하는 방법을 권장한다.
  
### equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다.
  equals는 항시 메모리에 존재하는 객체만을 사용한 결정적 계산만 수행해야 한다.
  
### 양질의 equals메소드를 구현하는 단계
  1. == 연산자를 사용하여 입력이 자기 자신의 참조인지 확인한다.
  2. instanceof연산자로 입력이 올바른 타입인지 확인한다. 그렇지 않다면 false를 반환한다.
  3. 입력을 올바른 타입으로 형변환한다.
  4. 입력 객체와 자기 자신의 대응되는 '핵심'필드들이 모두 일치하는지 하나하나 검사한다.

### 
  
